* 리액트 (React)
  공식 사이트: https://reactjs.org/docs/getting-started.html
  리액트 실행: https://create-react-app.dev/docs/getting-started

- 환경설정
  Create React App: 간편하게 싱글페이지 어플리케이션을 만들때 사용
  Next JS: Server Side 렌더링을 할 때 사용
  Garsby: 정적인 사이트를 리액트를 이용해서 만들때 사용

- 유저 인터페이스를 만들수 있는 라이브러리로 사용자에게 보여지는 UI를 만들고 그 위에서 
  사용자가 클릭을 하거나 다양한 이벤트가 발생하게 되면 그에 맞게 반응하도록 만들어진 라이브러리
  또는 웹 UI를 만드는 라이브러리이다.

  리액트를 한 단어로 정의를 하자면 컴포넌트(Component)들이라고 할 수 있다.

  리액트는 Virtual DOM Tree (가상 돔 트리)가 있다. 

  사용자가 조금 더 부드럽게 웹 어플리케이션을 이용하기 위해서는 60 frames per seconds(60fps)를 유지해야 한다.
  즉, 1초 안에 60개의 프레임이 업데이트 될 수 있도록 성능을 신경써서 만들어야 하는데 리액트는 이것을 자동으로 보장해준다.

  조금 복잡한 웹 어플리케이션을 만들 때 MVC (Model, View, Controller) 패턴을 많이 이용하는데,
  이중에서 리액트는 View Layer를 담당한다.


* 컴포넌트 (Component)

- 컴포넌트는 버튼 하나와 같이 한 가지의 기능을 수행하는 UI 단위이다.
  컴포넌트는 서로 독립적이고 잘 고립되어져 있으며, 재사용이 가능한 것을 말한다.

  컴포넌트는 다른 컴포넌트와는 독립적으로 그 컴포넌트에 해당하는 로직과 그 컴포넌트에 해당하는 state(상태)가 들어 있기 때문에
  Cohesive(응집적)이다 라고 말할 수 있다.

  리액트에서 컴포넌트를 사용하는 방법은 리액트에서 제공하는 컴포넌트라는 클래스를 상속해야 한다.
  
  class LikeButton extends Component {
      state = {
          numberOfLikes: 0,
      };

      render() {
          return <button>
            { this.state.numberOfLikes }
          </button>;
      }
  }

  export default LikeButton;

  이 컴포넌트 클래스 안에는 state 부분과 redering 하는 부분 이 두가지로 나눠 볼 수 있다.

  state: 이 컴포넌트에 들어 있는 데이터를 나타내는 오브젝트
  render(): 어떻게 사용자에게 표기될 건지 (HTML과 비슷한, 또는 JSX 라고 부른다.)를 표현

  리액트는 이 state 라는 오브젝트에 데이터가 변경이 되면 render 함수가 자동적으로 호출되는데
  이렇게 변경된 state의 값이 화면에 나타날 수 있도록 render 함수가 계속 반복적으로 호출된다.

  컴포넌트를 만드는 방법 중에는 크게 Class Component, Function Component가 있다.

  Class Component: 리액트에서 제공하는 컴포넌트라는 클래스를 상속 받아 만들수 있다.
  Function Component: 간단한 함수로 만들수 있다.
  
  function App() {
    return <h1>Hello</h1>
  }

  컴포넌트가 state가 있고 그 상태에 따라서 컴포넌트가 주기적으로 업데이트 돼야 한다면 클래스 컴포넌트 사용
  컴포넌트에 state가 없고 항상 정적인 상태라면 간단하게 함수 컴포넌트 사용
  
  클래스 컴포넌트는 라이프 사이클 메소드가 있는 반면에 함수 컴포넌트는 한가지 일만 수행하기 때문에 라이프 사이클 메소드가 없다.
  React Hooks를 사용하면 함수 컴포넌트에서도 state 값을 가질수 있고, 라이프 사이클 메소드도 사용할 수 있다.

  라이프 사이클 메소드는 컴포넌트가 마운트 되었을 때, 언마운트 되었을 때, 또는 업데이트 되었을 때 이렇게 세부적으로 나눠져 있어서
  중복되는 코드를 작성해야 하는 경우가 있었는데 Hooks를 이용하면 중복을 제거할 수 있다.

  이렇게 리액트에는 리액트에서 제공하는 React.Component가 있고, function 컴포넌트가 있다.
  그리고 React.PureComponent도 있고 이거랑 비슷한 memo라는 함수형 컴포넌트가 있고 마지막으로 state와 라이프 사이클이 가능한 React Hooks도 있다.

* Mount   : 나타나는 것을 의미한다. 컴포넌트가 나타나는 것을 마운트
* Unmount : 삭제 될 때는 언마운트라고 한다.

* 라이프 사이클 메소드(Lifecycle Method): 컴포넌트가 사용자에게 보여질 때 또는 업데이트 됐을 때, 돔 트리에 올라갔을 때 또는 나왔을 때 등등
  이런 다양한 컴포넌트의 상태에 따라서 알아서 기능을 해준다.


* 가상의 돔 트리 (Virtual DOM Tree)

- 리액트의 컴포넌트들이 메모리상에 보관 되어져 있다. 즉, 바로 리액트의 모든 구조들이 돔 트리에 업데이트 되는것이 아니다.

  컴포넌트에 변동사항이 생겨 자식 컴포넌트에 render 함수가 호출이 되면
  이전의 Virtual DOM Tree와 비교해서 실질적으로 어떤 부분이 업데이트 돼야 하는지 계산한 다음 필요한 부분만 업데이트 한다.

  그래서 render 함수가 많이 호출 되어도 실질적으로 보여지는 데이터가 변동이 되지 않으면
  돔 트리에 전혀 영향을 주지 않기 때문에 성능이 떨이지지 않는다.


* 프레임워크와 라이브러리의 차이점

- 쉽게 단적인 예로 설명하자면
  프레임워크는 이미 집의 구조나 철제들이 완성된 상태의 완성품으로 벽돌의 색깔을 바꿔서 벽돌을 붙이거나
  집안의 가구를 재배치 하는 등의 일들을 할 수 있다. 

  라이브러리는 우리가 원하는 재료들을 골라서 우리의 입맛에 맞게 집을 지을 수 있다.
  그래서 조금 조금의 만들어진 재료들을 라이브러리라고 할 수 있다.

  (Frameworks)
  프레임워크의 대표적인 예는 앵귤러로 UI, Routing, State를 관리하는 방식, HTTP Clients 등등 굉장히 다양한
  기능들이 한번에 묶여서 제공된다.
  그래서 앵귤러를 이용해서 웹 어플리케이션을 만들려면 앵귤러에서 제공하는 기능들을 이용해 만들어야 한다.

  즉, 프레임워크는 정해진 골격 안에서 우리가 원하는 기능을 구현해야 한다.

  (React)
  반대로 라이브러리는 UI를 관리하는 라이브러리, 라우팅에 관련된 라이브러리들, 스테이트를 관리할 수 있는 라이브러리,
  작은 단위, 작은 도메인 안에서 자신들이 원하는 작은 부분을 구현한 것을 라이브러리라고 한다.

  프레임워크와는 다르게 따로 정해진 골격이 없기 때문에 원하는 구조의 집을 만들수 있고, 필요한 기능에 따라서
  라이브러리를 골라 사용할 수 있다.


* 리액트의 정의, 컴포넌트의 정의, 성능이 좋은 이유에 대한 짧은 정리

  리액트는 컴포넌트 단위로 이루어진 UI를 만들 수 있는 라이브러리 이다.

  컴포넌트는 독립적이고 고립되어 있으며 재사용이 가능하다.
  그렇기 때문에 테스팅(유닛테스트)을 하기가 좋다.

  이 컴포넌트는 데이터 오브젝트를 갖고 있는 state, 사용자에게 어떻게 보여줄 건지를 정의하는 render 함수가 있다.
  그리고 상태가 변화될 때 마다 render 함수가 계속 호출이 된다.

  그런데도 성능이 괜찮은 이유는 리액트 내부에 VDOM (가상의 돔 트리)이 있기 때문이다.

* Pure Component, Memo Component
  컴포넌트의 state나 props가 변화가 없다면 render()가 불려지지 않는다.
  즉, 최상위에 있는 데이터가 변하지 않으면 render()가 호출 되지 않는다.

  그냥 Component와 달리 Pure Component는 shouldComponentUpdate()가 구현되어 있다.

  이것은 Component가 업데이트가 되기 전에 갖고 있던 state나 props를 업데이트가 될 props와 state를 가볍게 비교한 후 같으면
  업데이트를 할 필요가 없으므로 shouldComponentUpdate()는 false 값을 리턴, 업데이트 할 필요가 있으면 shouldComponentUpdate()는 true 값을 리턴한다.

  한마디로 동일한 오브젝트를 갖고 있으면 값이 변경되어도 크게 달라진게 없어 변경되지 않지만,
  오브젝트를 아예 새로 생성해서(가르키는 주소 값이 달라져서) 변경하면 PureComponent를 잘 사용할 수 있다. (Habit tracker 이해하기)

  공식 사이트: https://reactjs.org/docs/react-api.html#reactpurecomponent

* 클래스 안에 있는 멤버 변수들은 클래스가 만들어질 때 딱 한 번만 만들어진다.
  대신에 state가 변경되거나 props가 업데이트가 되면 render()만 계속 반복해서 호출이 된다.
  그래서 클래스 안에서 멤버 변수는 한번만 할당이 되어지는 반면에

  함수는 컴포넌트가 변경이 되면 코드블럭 전체가 계속 반복해서 호출이 된다.
  즉, function Component는 props나 state가 변경이 되면 전부 반복이 되고 지역 변수들도
  무한정 반복된다.

  그래서 onClick에 전달한 콜백 함수는 첫 번째 불려졌을 때 새로운 함수가 만들어진다.

  또한 반복적으로 reateRef()처럼 매번 새로운 레퍼런스를 만드는 것이 아니라
  한 번만 만들고 메모리에 저장해 놓은 다음 그것을 재사용 하는 useRef()를 쓴다.

  그리고 비슷한 것으로 함수도 계속 호출될 때마다 재생성 되는것을 막기 위해 함수에는
  useCallback()이 있다.